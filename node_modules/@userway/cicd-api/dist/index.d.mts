import { RuleDescriptor as RuleDescriptor$1 } from '@userway/a11y-knowledge-base';

declare enum ScanRuleLevel {
    A = "A",
    AA = "AA",
    AAA = "AAA",
    BESTPRACTICE = "BESTPRACTICE",
    EXPERIMENTAL = "EXPERIMENTAL"
}
declare enum ScanRuleSeverity {
    MINOR = "MINOR",
    MODERATE = "MODERATE",
    SERIOUS = "SERIOUS",
    CRITICAL = "CRITICAL"
}

interface DateTime {
    dateTimestamp: number;
    dateReadable: string;
}
interface Pageable<T> {
    thisPageItems: T[];
    thisPageIndex: number;
    totalNumber: number;
    moreAvailable: boolean;
    lastPageIndex: number;
    pageItemType: string;
}
interface PageableQuery {
    pageIndex: number;
    pageSize: number;
}
declare enum SortOrder {
    ASC = "asc",
    DESC = "desc"
}
declare enum ContinuousAccessibilityApiErrorType {
    INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
    INPUT_VALIDATION_ERROR = "INPUT_VALIDATION_ERROR",
    NOT_FOUND_ERROR = "NOT_FOUND_ERROR",
    ORGANIZATION_NOT_FOUND_ERROR = "ORGANIZATION_NOT_FOUND_ERROR",
    PROJECT_NOT_FOUND_ERROR = "PROJECT_NOT_FOUND_ERROR",
    ALM_INSTANCE_NOT_FOUND_ERROR = "ALM_INSTANCE_NOT_FOUND_ERROR",
    ISSUE_NOT_FOUND_ERROR = "ISSUE_NOT_FOUND_ERROR",
    BANNER_NOT_FOUND_ERROR = "BANNER_NOT_FOUND_ERROR",
    INVITATION_NOT_FOUND_ERROR = "INVITATION_NOT_FOUND_ERROR",
    HTTP_ERROR = "HTTP_ERROR",
    SSO_API_ERROR = "SSO_API_ERROR",
    DATABASE_ERROR = "DATABASE_ERROR",
    DUPLICATE_ERROR = "DUPLICATE_ERROR",
    MAIN_BRANCH_NOT_SCANNED_ERROR = "MAIN_BRANCH_NOT_SCANNED_ERROR",
    SCAN_TARGET_NOT_SCANNED_ERROR = "SCAN_TARGET_NOT_SCANNED_ERROR",
    SCAN_NOT_PROCESSED_ERROR = "SCAN_NOT_PROCESSED_ERROR",
    SCAN_TARGET_NOT_FOUND_ERROR = "SCAN_TARGET_NOT_FOUND_ERROR",
    SCAN_TARGET_CONFIG_MISMATCH_ERROR = "SCAN_TARGET_CONFIG_MISMATCH_ERROR",
    SCAN_TARGET_DELTA_SCOPE_ERROR = "SCAN_TARGET_DELTA_SCOPE_ERROR",
    SCAN_ARTIFACT_UPLOAD_ERROR = "SCAN_ARTIFACT_UPLOAD_ERROR",
    SCAN_TARGET_CIRCULAR_DEPENDENCY_ERROR = "SCAN_TARGET_CIRCULAR_DEPENDENCY_ERROR",
    SCAN_TARGET_BROKEN_DEPENDENCY_CHAIN_ERROR = "SCAN_TARGET_BROKEN_DEPENDENCY_CHAIN_ERROR",
    CANNOT_DELETE_QUALITY_GATE_ERROR = "CANNOT_DELETE_QUALITY_GATE_ERROR",
    QUALITY_GATE_LIMIT_PER_ORGANIZATION_REACHED = "QUALITY_GATE_LIMIT_PER_ORGANIZATION_REACHED",
    INVALID_MEMBER_STATUS_ERROR = "INVALID_MEMBER_STATUS_ERROR",
    ISSUE_CLOSED_ERROR = "ISSUE_CLOSED_ERROR",
    ANNOTATION_ERROR = "ANNOTATION_ERROR",
    CANNOT_MODIFY_BUILT_IN_QUALITY_GATE_ERROR = "CANNOT_MODIFY_BUILT_IN_QUALITY_GATE_ERROR",
    CANNOT_MODIFY_CLOSED_ISSUE_ERROR = "CANNOT_MODIFY_CLOSED_ISSUE_ERROR",
    CLOUD_COMMIT_SCAN_PROCESS_ERROR = "CLOUD_COMMIT_SCAN_PROCESS_ERROR",
    COMMIT_SCAN_PROCESS_ERROR = "COMMIT_SCAN_PROCESS_ERROR",
    SCAN_STATUS_CONFLICT_ERROR = "SCAN_STATUS_CONFLICT_ERROR",
    SNAPSHOT_SCAN_PROCESS_ERROR = "SNAPSHOT_SCAN_PROCESS_ERROR",
    BASELINE_DELTA_ERROR = "BASELINE_DELTA_ERROR",
    QUOTA_BALANCE_EXCEEDED_ERROR = "QUOTA_BALANCE_EXCEEDED_ERROR",
    ADMIN_CANNOT_BE_DELETE_ERROR = "ADMIN_CANNOT_BE_DELETE_ERROR",
    ADMIN_CANNOT_BE_SUSPEND_ERROR = "ADMIN_CANNOT_BE_SUSPEND_ERROR",
    SUBSCRIPTION_NOT_FOUND_ERROR = "SUBSCRIPTION_NOT_FOUND_ERROR",
    PAYMENT_METHOD_NOT_FOUND_ERROR = "PAYMENT_METHOD_NOT_FOUND_ERROR",
    PRODUCT_NOT_FOUND_ERROR = "PRODUCT_NOT_FOUND_ERROR",
    USERWAY_API_ERROR = "USERWAY_API_ERROR",
    GITHUB_API_ERROR = "GITHUB_API_ERROR",
    DOCKERHUB_API_ERROR = "DOCKERHUB_API_ERROR",
    NPM_API_ERROR = "NPM_API_ERROR",
    VISUAL_STUDIO_MARKETPLACE_API_ERROR = "VISUAL_STUDIO_MARKETPLACE_API_ERROR",
    ONLY_OWNER_CAN_MODIFY_COMMENT_ERROR = "ONLY_OWNER_CAN_MODIFY_COMMENT_ERROR",
    DISCONNECTED_CREDENTIALS_ERROR = "DISCONNECTED_CREDENTIALS_ERROR",
    PROJECT_DISCONNECTED_ERROR = "PROJECT_DISCONNECTED_ERROR",
    INVALID_GITLAB_OAUTH_CODE = "INVALID_GITLAB_OAUTH_CODE",
    CANNOT_TRANSLATE_BILLING_CYCLE = "CANNOT_TRANSLATE_BILLING_CYCLE",
    MAIN_BRANCH_CANNOT_BE_REMOVED_ERROR = "MAIN_BRANCH_CANNOT_BE_REMOVED_ERROR",
    CORE_LAMBDA_RESPONSE_ERROR = "CORE_LAMBDA_RESPONSE_ERROR",
    AZURE_VERIFY_EXCEPTION = "AZURE_VERIFY_EXCEPTION",
    ONLY_MAIN_BRANCH_CAN_BE_RENAMED = "ONLY_MAIN_BRANCH_CAN_BE_RENAMED",
    CANNOT_DOWNGRADE_ERROR = "CANNOT_DOWNGRADE_ERROR",
    MULTIPLE_SUBSCRIPTIONS_PER_PRODUCT_ARE_DISALLOWED = "MULTIPLE_SUBSCRIPTIONS_PER_PRODUCT_ARE_DISALLOWED",
    SCAN_STUCK_ERROR = "SCAN_STUCK_ERROR",
    FILE_LIMIT_ERROR = "FILE_LIMIT_ERROR",
    INVITATION_LINK_WAS_DEACTIVATED = "INVITATION_LINK_WAS_DEACTIVATED",
    INVITATION_LINK_HAS_EXPIRED = "INVITATION_LINK_HAS_EXPIRED"
}
type NotFoundErrorType = ContinuousAccessibilityApiErrorType.NOT_FOUND_ERROR | ContinuousAccessibilityApiErrorType.PROJECT_NOT_FOUND_ERROR | ContinuousAccessibilityApiErrorType.ORGANIZATION_NOT_FOUND_ERROR | ContinuousAccessibilityApiErrorType.ALM_INSTANCE_NOT_FOUND_ERROR | ContinuousAccessibilityApiErrorType.INVITATION_NOT_FOUND_ERROR | ContinuousAccessibilityApiErrorType.ISSUE_NOT_FOUND_ERROR;
interface MessageResponse {
    msg: string;
    aux: string | null;
}
interface RuleDescriptorReference {
    label: string;
    url: string;
}
interface RuleDescriptor {
    description: string;
    display: string;
    errorMessage: string;
    level: ScanRuleLevel;
    key: string;
    references: RuleDescriptorReference[];
    recommendation: string;
    severity: ScanRuleSeverity;
    fixable: boolean;
}
declare enum ScanStatus {
    UPLOADING = "UPLOADING",
    QUEUED = "QUEUED",
    PROCESSING = "PROCESSING",
    PROCESSED = "PROCESSED",
    READY = "READY",
    FAILED = "FAILED"
}
declare enum NumberScansFilter {
    LESS_THAN_FIVE = "LESS_THAN_FIVE",
    BETWEEN_FIVE_TWENTY = "BETWEEN_FIVE_TWENTY",
    BETWEEN_TWENTY_FIFTY = "BETWEEN_TWENTY_FIFTY",
    BETWEEN_FIFTY_HUNDRED = "BETWEEN_FIFTY_HUNDRED",
    MORE_THAN_HUNDRED = "MORE_THAN_HUNDRED"
}
declare enum AccessibilityScoreFilter {
    LESS_THAN_FIFTY = "LESS_THAN_FIFTY",
    BETWEEN_FIFTY_SEVENTY_FIVE = "BETWEEN_FIFTY_SEVENTY_FIVE",
    MORE_THAN_SEVENTY_FIVE = "MORE_THAN_SEVENTY_FIVE"
}
declare enum AnalysisScope {
    DELTA = "DELTA",
    OVERALL = "OVERALL"
}
interface CountByOrganizationIds {
    count: number;
    id: string;
}

declare enum Integration {
    AZURE = "AZURE",
    BITBUCKET = "BITBUCKET",
    GITHUB = "GITHUB",
    GITLAB = "GITLAB",
    MANUAL = "MANUAL"
}
declare enum ProjectType {
    SITE = "SITE",
    ALM = "ALM"
}
interface ProjectSetupInstructions {
    almType: Alm;
    testFrameworks: TestFramework[];
    projectToken: string;
    repositoryVariablesURL: string | null;
}
interface Project {
    id: string;
    organizationId: string;
    integration: Integration;
    type: ProjectType;
    name: string;
    encryptedToken: string;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface ProjectDecryptedToken {
    id: string;
    organizationId: string;
    workspaceId: string | null;
    repositoryId: string | null;
    qualityGateId: string | null;
    name: string;
    token: string;
    ignoreFixable: boolean;
    detectTemplateLevelIssues: boolean;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface ProjectList extends Pageable<Project> {
    organizationId: string;
}
interface UpdateProjectName {
    name: string;
}
interface SetDefaultAssignee {
    memberId: string | null;
}
interface CreateProject {
    name: string;
}
interface ProjectNameCompatible {
    slug: string;
}
interface ProjectBriefInfo extends Omit<Project, 'encryptedToken'> {
    type: ProjectType;
    integration: Integration;
    scanned: boolean;
}
interface ProjectNameExists {
    exists: boolean;
}

interface ProjectSettingsBase {
    id: string;
    projectName: string;
    decryptedToken: string;
    ignoreFixable: boolean;
    detectTemplateLevelIssues: boolean;
    qualityGateId: string;
    qualityGateName: string;
    qualityGateEnabled: boolean;
    urlParamsEnabled: boolean;
    pageTemplates: string[];
    defaultAssigneeId: string | null;
}
interface ProjectSettingsAlm extends ProjectSettingsBase {
    projectType: ProjectType.ALM;
    alm: ProjectSettingsAlmInfo;
}
interface ProjectSettingsSite extends ProjectSettingsBase {
    projectType: ProjectType.SITE;
    alm: null;
}
type ProjectSettings = ProjectSettingsAlm | ProjectSettingsSite;
interface UpdateProjectSettingsIgnoreFixable {
    ignoreFixable: boolean;
}
interface UpdateProjectSettingsDetectTemplateIssues {
    detectTemplateLevelIssues: boolean;
}
interface UpdateProjectSettingsGateStatus {
    qualityGateEnabled: boolean;
}
interface UpdateProjectSettingsGateId {
    qualityGateId: string;
}
interface UpdateProjectSettingsUrlParams {
    urlParamsEnabled: boolean;
}
interface UpdateProjectSettingsPageTemplates {
    pageTemplates: string[];
}
interface CreateProjectSettings {
    urlParamsEnabled?: boolean;
    pageTemplates?: string[];
}
interface RenameMainBranch {
    branchName: string;
}

declare enum Alm {
    AZURE = "AZURE",
    BITBUCKET = "BITBUCKET",
    GITHUB = "GITHUB",
    GITLAB = "GITLAB",
    MANUAL = "MANUAL"
}
declare enum RetentionType {
    SHORT = "SHORT",
    LONG = "LONG"
}
interface Assignee {
    email: string;
}
interface ProjectSettingsAlmInfo {
    mainBranch: string;
    mainBranchId: string;
}
interface CreateRepositoryEntity {
    mainBranchName: string;
}
interface CreateRepositorySettings {
    settings: CreateProjectSettings;
    repository: CreateRepositoryEntity;
}
interface CreateRepository extends CreateRepositorySettings {
    project: CreateProject;
}
interface CreateRepositories extends CreateRepositorySettings {
    projects: CreateProject[];
}

declare enum AlmInstanceType {
    MAIN_BRANCH = "MAIN_BRANCH",
    BRANCH = "BRANCH",
    PULL_REQUEST = "PULL_REQUEST"
}
interface AlmInstance {
    type: AlmInstanceType;
    branchName: string;
    repositoryId: string;
    targetAlmInstanceId: string | null;
    instanceId: string | null;
    pullRequestName: string | null;
    pullRequestKey: string | null;
    pullRequestAuthorId: string | null;
    retention: RetentionType;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface AlmInstanceList extends Pageable<AlmInstance> {
    projectId: string;
}
type AlmInstanceGroupCount = Record<AlmInstanceType, number>;

interface AzureRepository {
    id: string;
    projectId: string;
    name: string;
    projectName: string;
    mainBranchName: string;
    imported: boolean;
}
interface AzureRepositories {
    organizationSlug: string;
    organizationId: string;
    items: AzureRepository[];
}
interface CreateAzureOrganization {
    organizationName: string;
    personalAccessToken: string;
}
interface AzureRepositoryEntity {
    externalProjectId: string;
    externalId: string;
}
interface CreateAzureRepository extends CreateRepository {
    azureRepository: AzureRepositoryEntity;
}
interface CreateAzureRepositories extends CreateRepositories {
    azureRepository: AzureRepositoryEntity;
}
interface AzureOrganization {
    readonly id: string;
    readonly isValid: boolean;
    readonly name: string;
    readonly encryptedPersonalAccessToken: string;
    readonly ssoOrganizationId: string;
    readonly createdAt: DateTime;
    readonly updatedAt: DateTime;
}
interface AzureReport {
    readonly report: string;
}
interface ReconnectAzureOrganization {
    personalAccessToken: string;
}
interface CreatedAzureRepository {
    id: string;
    organizationId: string;
    externalId: string;
    externalProjectId: string;
    name: string;
    projectName: string;
}
interface CreatedAzureRepositories {
    items: CreatedAzureRepository[];
}

interface RenameQualityGate {
    name: string;
}
interface QualityGate {
    id: string;
    organizationId: string;
    name: string;
    isDefault: boolean;
    isBuiltIn: boolean;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface ProjectQualityGateData {
    name: string;
    issues: number;
    lastScanDate: DateTime | null;
    id: string;
    integration: Integration;
}
interface QualityGateWithUsedProjectsData extends QualityGate {
    projects: ProjectQualityGateData[];
    isUsedInProjects: boolean;
    countProjects: number;
}
interface NewQualityGate {
    name: string;
}
interface ListQualityGate extends Pageable<QualityGateWithUsedProjectsData> {
    organizationId: string;
}
declare enum QualityGateMetricSummary {
    ISSUES_FOUND = "ISSUES_FOUND",
    RULES_FAILED = "RULES_FAILED",
    A11Y_SCORE = "A11Y_SCORE"
}
declare enum QualityGateAction {
    FAIL_IF = "FAIL_IF",
    WARN_IF = "WARN_IF",
    OFF = "OFF"
}
declare enum QualityGateOperator {
    GREATER = "GREATER",
    LESS = "LESS",
    EQUAL = "EQUAL",
    GREATER_OR_EQUAL = "GREATER_OR_EQUAL",
    LESS_OR_EQUAL = "LESS_OR_EQUAL"
}
declare enum QualityGateMetric {
    ISSUES_FOUND = "ISSUES_FOUND",
    MINOR = "MINOR",
    MODERATE = "MODERATE",
    SERIOUS = "SERIOUS",
    CRITICAL = "CRITICAL",
    A = "A",
    AA = "AA",
    AAA = "AAA",
    BEST_PRACTICE = "BEST_PRACTICE",
    EXPERIMENTAL = "EXPERIMENTAL",
    A11Y_SCORE = "A11Y_SCORE",
    RULES_FAILED = "RULES_FAILED",
    ACCEPTED_ISSUES = "ACCEPTED_ISSUES"
}

declare enum QualityGateScope {
    DELTA = "DELTA",
    OVERALL = "OVERALL"
}
declare enum QualityGateMetricInitial {
    MINOR = "MINOR",
    MODERATE = "MODERATE",
    SERIOUS = "SERIOUS",
    CRITICAL = "CRITICAL",
    A11Y_SCORE = "A11Y_SCORE",
    ACCEPTED_ISSUES = "ACCEPTED_ISSUES"
}
interface QualityGateCondition {
    id: string;
    qualityGateId: string;
    metricName: QualityGateMetric;
    scope: QualityGateScope;
    threshold: number;
    operator: QualityGateOperator;
    action: QualityGateAction;
}
interface NewQualityGateCondition {
    metricName: QualityGateMetric;
    scope: QualityGateScope;
    action: QualityGateAction;
    threshold: number;
}
interface UpdateQualityGateCondition {
    threshold?: number;
    action?: QualityGateAction;
}
interface QualityGateConditionBrief {
    threshold: number;
    action: QualityGateAction;
    operator: QualityGateOperator;
    id: string;
}
type QualityGateMetricConditions = Record<QualityGateMetricInitial, QualityGateConditionBrief>;
type QualityGateConditions = Record<QualityGateScope, QualityGateMetricConditions>;
interface QualityGateConditionBriefBatch {
    threshold: number;
    action: QualityGateAction;
}
type QualityGateMetricBatch = Record<QualityGateMetricInitial, QualityGateConditionBriefBatch>;
type QualityGateConditionBatch = Record<QualityGateScope, QualityGateMetricBatch>;

declare enum LawsuitRiskStatus {
    HIGH = "HIGH",
    LOW = "LOW"
}
declare enum QualityGateRuleStatus {
    FAILED = "FAILED",
    PASSED = "PASSED",
    WARNING = "WARNING"
}
declare enum ScanScoreOutcome {
    FAILED = "FAILED",
    PASSED = "PASSED"
}
interface ScanScore {
    scanId: string;
    outcome: ScanScoreOutcome;
    createdAt: DateTime;
}

interface BitbucketRepository {
    slug: string;
    externalId: string;
    mainBranchName: string;
    imported: boolean;
}
interface BitbucketRepositories {
    organizationSlug: string;
    workspaceId: string;
    items: BitbucketRepository[];
}
interface PackageLastVersion {
    version: string;
}
type BitbucketPipeLastVersion = PackageLastVersion;
interface BitbucketInstalled {
    clientKey: string;
    sharedSecret: string;
    principal: {
        uuid: string;
        display_name: string;
        username?: string;
        nickname?: string;
    };
}
interface BitbucketUninstalled {
    clientKey: string;
    principal: {
        uuid: string;
        display_name: string;
    };
}
interface BitbucketInstallation {
    id: string;
    name: string;
    externalId: string;
}
interface BitbucketWorkspace {
    installationId: string;
    ssoOrganizationId: string;
}
interface BitbucketWorkspaceWithInstallation {
    id: string;
    ssoOrganizationId: string;
    isValid: boolean;
    externalId: string;
    name: string;
}
interface CreateBitbucketWorkspace {
    clientKey: string;
}
interface BitbucketRepositoryEntity {
    slug: string;
    externalId: string;
}
interface CreateBitbucketRepository extends CreateRepository {
    bitbucketRepository: BitbucketRepositoryEntity;
}
interface CreateBitbucketRepositories extends CreateRepositories {
    bitbucketRepository: BitbucketRepositoryEntity;
}
interface BitbucketWidgetProjectPayload {
    outcome: ScanScoreOutcome;
    items: {
        status: QualityGateRuleStatus;
        scope: QualityGateScope;
        metric: QualityGateMetric;
        threshold: number | null;
        value: number;
    }[];
    context: {
        organizationSlug: string;
        projectName: string;
        almInstanceId: string;
    };
}
interface BitbucketWidgetPayload {
    projects: BitbucketWidgetProjectPayload[];
}
interface BitbucketCreatedRepository {
    id: string;
    workspaceId: string;
    slug: string;
    externalId: string;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface BitbucketCreatedRepositories {
    items: BitbucketCreatedRepository[];
}

interface Connection {
    id: string;
    integration: Integration;
    organizationId: string;
    createdAt: DateTime;
    projects: number;
    name: string;
    isValid: boolean;
    integrationUrl: string;
}

interface GitHubInstallation {
    id: number;
}
interface GitHubOrganization {
    id: string;
    isValid: boolean;
    externalId: number;
    name: string;
    ssoOrganizationId: string;
}
interface GitHubRepository {
    externalId: number;
    name: string;
    mainBranchName: string;
    imported: boolean;
}
interface GitHubRepositories {
    organizationSlug: string;
    organizationId: string;
    items: GitHubRepository[];
}
interface GitHubRepositoryEntity {
    name: string;
    externalId: number;
}
interface CreateGitHubRepository extends CreateRepository {
    gitHubRepository: GitHubRepositoryEntity;
}
interface CreateGitHubRepositories extends CreateRepositories {
    gitHubRepository: GitHubRepositoryEntity;
}
interface CreatedGitHubRepository {
    id: string;
    name: string;
    externalId: number;
    organizationId: string;
    updatedAt: DateTime;
    createdAt: DateTime;
}
interface CreatedGithubRepositories {
    items: CreatedGitHubRepository[];
}

interface CreateGitLabConnection {
    authCode: string;
}
interface ReconnectGitLabConnection {
    authCode: string;
}
interface GitLabConnectionResponse {
    connectionId: string;
    name: string;
    isValid: boolean;
}
interface GetGitLabProjectsQuery {
    connectionId: string;
}
interface GitLabProject {
    id: number;
    name: string;
    mainBranchName: string;
    imported: boolean;
}
interface GitLabProjects {
    organizationSlug: string;
    connectionId: string;
    items: GitLabProject[];
}
interface GitLabProjectsResponse {
    projects: GitLabProject[];
}
interface GitLabRepositoryEntity {
    externalId: number;
}
interface CreateGitLabRepository extends CreateRepository {
    gitLabRepository: GitLabRepositoryEntity;
}
interface CreateGitLabRepositories extends CreateRepositories {
    gitLabRepository: GitLabRepositoryEntity;
}
interface GitLabRepositoryRepositoryDto {
    id: string;
    repositoryId: number;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface CreatedGitLabRepository {
    id: string;
    connectionId: string;
    externalId: number;
    name: string;
    displayName: string;
    organizationName: string;
    organizationDisplayName: string;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface CreatedGitLabRepositories {
    items: CreatedGitLabRepository[];
}

interface NewManualRepository {
    name: string;
    urlParamsEnabled: boolean;
    pageTemplates?: string[];
}
interface Repository {
    id: string;
    type: Alm;
    projectName: string;
    createdAt: DateTime;
    updatedAt: DateTime;
}

interface CreatedManualRepositories {
    items: Repository[];
}

declare enum ArtifactType {
    PAGE = "PAGE",
    REPORT = "REPORT",
    IMAGE = "IMAGE"
}
declare enum ArtifactSource {
    LAMBDA = "LAMBDA",
    CICD = "CICD"
}
interface Artifact {
    path: string;
    type: ArtifactType;
}
interface ScanArtifact {
    path: string;
    type: ArtifactType;
    /** The file size of artifact in bytes */
    size: number;
}
declare enum ScanArtifactUploadStatus {
    SUCCEED = "SUCCEED",
    FAILED = "FAILED"
}
interface ScanArtifactUploadMeta {
    type: ArtifactType;
    s3Path: string;
}
interface ScanArtifactUploadFormData {
    url: string;
    fields: Record<string, string>;
}
interface ScanArtifactUploadData {
    meta: ScanArtifactUploadMeta;
    formData: ScanArtifactUploadFormData;
}
interface ScanArtifactUploadResultData {
    status: ScanArtifactUploadStatus;
    errorMessage?: string;
}
interface ScanArtifactUploadResult {
    meta: ScanArtifactUploadMeta;
    data: ScanArtifactUploadResultData;
}
interface FinalizeArtifactConfiguration {
    assignee?: string;
}

declare enum BillingBannerType {
    START_FREE_TRIAL = "START_FREE_TRIAL",
    SUBSCRIBE_TO_SCAN = "SUBSCRIBE_TO_SCAN",
    QUOTA_EXCEEDED = "QUOTA_EXCEEDED",
    QUOTA_ALMOST_EXCEEDED = "QUOTA_ALMOST_EXCEEDED",
    BILLING_DUE_AUTORENEW_DISABLED = "BILLING_DUE_AUTORENEW_DISABLED"
}
interface BillingBanner {
    type: BillingBannerType;
    productType: A11yTransactionType;
    details: Record<string, string>;
}
interface BillingBannerResponse {
    billingBanner: BillingBanner | null;
}
interface CloseBanner {
    billingBannerType: BillingBannerType;
}

declare enum A11yTransactionType {
    CA11Y_MANAGED = "CA11Y_MANAGED",
    CA11Y_SELF_HOSTED = "CA11Y_SELF_HOSTED"
}
declare enum UserServiceStatus {
    ACTIVE = "ACTIVE",
    PENDING = "PENDING",
    EXPIRED = "EXPIRED",
    CANCELED = "CANCELED"
}
declare enum SubscriptionStatus {
    INIT = "INIT",
    ACTIVE = "ACTIVE",
    REQUIRES_PAYMENT_METHOD = "REQUIRES_PAYMENT_METHOD",
    REQUIRES_AUTH = "REQUIRES_AUTH",
    PAST_DUE = "PAST_DUE",
    CLOSED = "CLOSED"
}
interface GetSubscription {
    type: A11yTransactionType;
}
interface BillingUserService {
    subscriptionId: number | null;
    userId: number;
    billingCycleMonths: number;
    startsAt: DateTime;
    expiresAt: DateTime | null;
    status: UserServiceStatus;
    comment: string | null;
    isTrial: boolean;
    subjectTransactionType: A11yTransactionType;
    managedByUserway: boolean;
}
interface IsDowngradeAvailable {
    type: A11yTransactionType;
    pricingTier: Ca11yTierType;
}
interface IsDowngradeAvailableResponse {
    isAvailable: boolean;
}
interface BillingUserwaySubscription {
    paymentProviderSubscriptionId: string;
    dateOfCancellation: DateTime | null;
    reasonOfCancellation: string | null;
    status: SubscriptionStatus;
}
interface Ca11yAddon {
    totalQuota: number;
    isRenewable: boolean;
}
interface GetHelperProductsBody {
    forceCalculation?: boolean;
    cancelRunningSubscription?: boolean;
    coupon?: string;
}
interface ProductStaticPricesTier {
    id: Ca11yTierType | null;
    quota: number | null;
    baseCostMonthly: number | null;
    baseCostYearly: number | null;
    baseCostBiAnnual: number | null;
    baseDiscountPercentYearly: number | null;
    baseDiscountPercentBiAnnual: number | null;
    baseCostMonthlyDiscounted: number | null;
    baseCostYearlyDiscounted: number | null;
    baseCostBiAnnualDiscounted: number | null;
    oneTimeCost: number | null;
    oneTimeCostDiscounted: number | null;
}
interface ProductStaticPrices {
    name: A11yTransactionType;
    id: string;
    tiers: ProductStaticPricesTier[];
}
interface StaticPrices {
    products: ProductStaticPrices[];
}
interface StripeCustomerId {
    stripeCustomerId: string;
}
declare enum WebInfoOrigin {
    USER = "USER",
    ADMIN = "ADMIN",
    AUTO_RENEW = "AUTO_RENEW"
}
declare enum BillingProvider {
    STRIPE = "STRIPE",
    BLUESNAP = "BLUESNAP",
    THIRD_PARTY = "THIRD_PARTY"
}
interface PaymentType {
    type: A11yTransactionType;
    title: string;
    cost: number;
}
interface PaymentHistory {
    id: number;
    createdAt: DateTime;
    invoiceIdentifier: string;
    total: number;
    paymentType: PaymentType[];
    billingCycle: SubscriptionBillingCycleType | null;
}
type PaymentHistoryList = Pageable<PaymentHistory>;
interface CardDetails {
    type: string;
    expYear: number;
    expMonth: number;
    lastFour: string;
    firstName: string;
    lastName: string | null;
}
declare enum BillingMethod {
    CREDIT_CARD = "CREDIT_CARD",
    BANK_TRANSFER = "BANK_TRANSFER"
}
interface PaymentMethodDetails {
    address: BillingAddress | null;
    uwPaymentDataId: number;
    providerPaymentMethodId: string;
    provider: BillingProvider;
    method: BillingMethod;
    isDefault: boolean;
    alias: string | null;
    card: CardDetails | null;
}
interface PaymentMethodsList {
    paymentMethods: PaymentMethodDetails[];
}
interface CreateSubscription {
    paymentMethodId: string;
    productType: A11yTransactionType;
    billingCycle: SubscriptionBillingCycleType;
    trial: boolean;
    coupon: string | null;
    pricingTier: Ca11yTierType;
}
interface CancelTrial {
    cancellationReason: string;
}
interface UpgradeSubscriptionBody {
    paymentMethodId: string;
    productType: A11yTransactionType;
    pricingTier: Ca11yTierType;
    billingCycle: SubscriptionBillingCycleType;
    forceCalculation?: boolean;
    cancelRunningSubscription?: boolean;
    coupon?: string;
}
interface CalculateCartSubscriptionUpgradeBody {
    productType: A11yTransactionType;
    pricingTier: Ca11yTierType;
    coupon: string | null;
    address: BillingAddress;
    paymentProviderSubscriptionId: string;
}
interface CreateTopUp {
    quota: number;
    transactionType: A11yTransactionType;
    expiredAt?: Date;
}
interface BillingEmails {
    emails: BillingEmailUser[];
}
interface GetPdfInvoice {
    token: string;
}
interface ToggleAutoRenew {
    isAutoRenew: boolean;
}
interface DowngradeSubscriptionBody {
    productName: A11yTransactionType;
    tier: Ca11yTierType;
}
interface SubscriptionTypeInfo {
    topUp: TopUp | null;
    subscription: Subscription | null;
    paymentMethod: {
        id: number;
    } | null;
    cost: number | null;
    quota: {
        used: number;
        remaining: number;
        total: number;
    };
}
interface SubscriptionInfo {
    managed: SubscriptionTypeInfo;
    selfHosted: SubscriptionTypeInfo;
}
interface BillingEmailUser {
    firstName: string;
    lastName: string;
    email: string;
}
interface BillingEmailUsers {
    users: BillingEmailUser[];
}
interface TopUp {
    id: string;
    organizationId: string;
    quota: number;
    transactionType: A11yTransactionType;
    expiredAt: DateTime;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface Product {
    quota: number;
    price: {
        monthly: number;
        yearly: number;
    };
}
interface Subscription {
    id: number;
    type: A11yTransactionType;
    paymentMethodId: number;
    quota: number;
    isRenewable: boolean;
    billingCycle: SubscriptionBillingCycleType;
    startAt: DateTime;
    endAt: DateTime;
    isTrial: boolean;
}
declare enum Ca11yTierType {
    LOW = "LOW",
    MEDIUM = "MEDIUM",
    HIGH = "HIGH",
    CUSTOM = "CUSTOM"
}

declare enum SubscriptionBillingCycleType {
    MONTHLY = "MONTHLY",
    ANNUAL = "ANNUAL",
    YEARLY = "YEARLY",// back compatibility, todo remove
    BIMONTHLY = "BIMONTHLY",
    QUARTERLY = "QUARTERLY"
}
interface BillingAddress {
    country: string;
    state: string | null;
    postalCode: string;
    city: string;
    line1: string;
}
interface CalculateCartBody {
    billingCycle: SubscriptionBillingCycleType;
    productType: A11yTransactionType;
    pricingTier: Ca11yTierType;
    coupon: string | null;
    address: BillingAddress | null;
}
/**
 * @typedef CartInvoiceTotals
 * @prop {number} taxUsd dollars
 * @prop {number} taxRate [0, 100]
 * @prop {number} discountUsd dollars
 * @prop {number} discountPercentage Percents %
 * @prop {number} totalUsd dollars (net)
 * @prop {number} subtotalUsd dollars (gross)
 */
interface CartInvoiceTotals {
    taxUsd: number;
    taxRate: number;
    discountUsd: number;
    discountPercentage: number;
    totalUsd: number;
    subtotalUsd: number;
}
interface BillingOrderItem {
    cost: number;
    discount: number;
    discountPercents: number;
}
interface CalculateCartPricing {
    couponApplied: boolean;
    invoiceDto: CartInvoiceTotals | null;
    estimate: BillingOrderItem[];
}

interface CommitScan {
    id: string;
    almInstanceId: string;
    projectVersion: string | null;
    createdAt: DateTime;
}
interface CommitScanStatus {
    commitScanId: string;
    status: ScanStatus;
    updatedAt: DateTime;
}

declare enum TestFramework {
    CYPRESS = "CYPRESS",
    PUPPETEER = "PUPPETEER",
    PLAYWRIGHT = "PLAYWRIGHT",
    USERWAY = "USERWAY",
    SELENIUM_JAVA = "SELENIUM_JAVA",
    SELENIUM_CSHARP = "SELENIUM_CSHARP",
    SELENIUM_PYTHON = "SELENIUM_PYTHON",
    WEBDRIVERIO = "WEBDRIVERIO"
}
interface Scan {
    id: string;
    baselineScanId: string | null;
    status: ScanStatus;
    testFrameworks: TestFramework[];
    failedReason: string | null;
    errorType: string | null;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface ScanList extends Pageable<Scan> {
    projectId: string;
}
interface ScanRelations {
    projectId: string;
    scanId: string;
}
interface ScansConsumption {
    projectName: string;
    quota: number;
    recentScanDate: DateTime;
}
interface ScansConsumptionQuery {
    type: A11yTransactionType;
}
interface ScanConsumptionResponse {
    projects: ScansConsumption[];
}
type Device = 'desktop' | 'mobile';
interface BasicAuth {
    type: 'basic';
    credentials: {
        username: string;
        password: string;
    };
}
interface FormAuth {
    type: 'form';
    url: string;
    credentials: {
        username: string;
        password: string;
    };
    selectors: {
        username: string;
        password: string;
        submit: string;
        additional: string[];
    };
}
interface ScriptAuth {
    type: 'script';
    url: string;
    script: string;
}
type Delay = '3 seconds' | '5 seconds' | '10 seconds' | '20 seconds' | '30 seconds' | '60 seconds' | '120 seconds';
type Action = 'scroll down 1 page' | 'scroll down 5 pages' | 'scroll down 10 pages' | 'scroll down 20 pages' | 'scroll down 40 pages';
interface Page {
    devices: Device[];
    auth?: BasicAuth | FormAuth | ScriptAuth;
    load?: {
        delay?: Delay;
        action?: Action;
    };
    rule?: {
        include?: string[];
        exclude?: string[];
    };
    script?: string;
    required?: boolean;
    reportIncomplete?: boolean;
    includeIframes?: boolean;
    screenshots?: boolean;
    fullPageScreenshot?: boolean;
    ignoreUrls?: string[];
    includeRules?: string[];
    excludeRules?: string[];
    includeBestPractices?: boolean;
    includeExperimental?: boolean;
    level?: 'A' | 'AA' | 'AAA';
    ignoreSelectors?: string[];
    switchOff?: boolean;
    ruleSpecificOptions?: {
        emptyAltAsPresentationalRole?: boolean;
    };
    rootSelector?: string;
}
interface CommitScanConfigPage extends Page {
    url: string;
}
interface CommitScanConfig {
    organization: string;
    project: string;
    branch: string;
    commitHash: string;
    commitMessage: string;
    commitCreatedAt: Date;
    contributorName: string;
    contributorEmail: string;
    targetBranch?: string;
    pullRequest?: number;
    timeout: number;
    server: string;
    verbose: boolean;
    isSpinnerEnabled: boolean;
    dryRun: boolean;
    assigneeEmail?: string;
    scope?: AnalysisScope;
    retention?: RetentionType;
    common?: Page;
    pages: CommitScanConfigPage[];
    connection?: string;
    reportPaths: string[];
    selfHostedReportsQuantity: number;
    concurrency: number;
}
interface ScanDocumentFilter {
    status?: ScanStatus[];
    errorType?: ContinuousAccessibilityApiErrorType[];
    integration?: Integration[];
    text?: string;
}
declare enum ScanSortField {
    CREATED_AT = "createdAt"
}
interface ScanSortableQuery {
    order?: SortOrder;
    field?: ScanSortField;
}
interface ScanDocumentQuery extends PageableQuery, ScanSortableQuery, ScanDocumentFilter {
}
interface QualityGateTableCondition {
    link?: string;
    value: string | number;
    name: string;
}
interface QualityGateTableRow {
    status: QualityGateRuleStatus;
    condition: QualityGateTableCondition;
    threshold: number | null;
}
interface QualityGateTable {
    rows: QualityGateTableRow[];
    summaryLink: string;
}

interface IssueDocumentAssignee {
    firstName: string;
    lastName: string | null;
    status: MemberStatus;
    id: string;
}
interface IssueDocument {
    id: string;
    projectId: string;
    instanceId: string;
    scanId: string;
    authorEmail: string | null;
    key: string;
    level: ScanRuleLevel;
    severity: ScanRuleSeverity;
    ruleDescriptor: RuleDescriptor;
    ruleKey: string;
    payloadS3Path: string;
    commentsCount: number;
    location: string;
    pageId: string;
    fixable: boolean;
    hasScreenshot: boolean;
    assignee: IssueDocumentAssignee | null;
    status: IssueStatus;
    resolution: IssueResolution;
    createdAt: DateTime;
    tags: string[];
    ruleId: number;
    userAgents: IssueUserAgent[];
}
interface IssueDocumentList extends Pageable<IssueDocument> {
    branchId: string;
    scanId: string;
}
interface IssueFacetsAssignee {
    count: number;
    name: string | null;
}
interface IssueDocumentFacets {
    severity: Record<ScanRuleSeverity, number>;
    level: Record<ScanRuleLevel, number>;
    location: Record<string, number>;
    ruleKey: Record<string, number>;
    ruleId: Record<string, number>;
    assignee: Record<string, IssueFacetsAssignee>;
    authorEmail: Record<string, number>;
    status: Record<IssueStatus, number>;
    resolution: Record<IssueResolution, number>;
    tags: Record<string, number>;
}
interface IssueDocumentFilter {
    level?: ScanRuleLevel[];
    tags?: string[];
    severity?: ScanRuleSeverity[];
    location?: string[];
    ruleKey?: string[];
    text?: string;
    authorEmail?: string[];
    assignee?: string[];
    status?: string[];
    resolution?: string[];
    ruleId?: number[];
}
declare enum IssueSortField {
    SEVERITY = "severity",
    CREATED_AT = "createdAt",
    WCAG = "level"
}
interface IssueSortableQuery {
    sortBy?: IssueSortField;
    order?: SortOrder;
}
interface IssueDocumentQuery extends IssueDocumentFilter, PageableQuery {
}

declare enum ScoreCellMetric {
    ISSUES_FOUND = "ISSUES_FOUND",
    MINOR = "MINOR",
    MODERATE = "MODERATE",
    SERIOUS = "SERIOUS",
    CRITICAL = "CRITICAL",
    A = "A",
    AA = "AA",
    AAA = "AAA",
    BEST_PRACTICE = "BEST_PRACTICE",
    EXPERIMENTAL = "EXPERIMENTAL",
    A11Y_SCORE = "A11Y_SCORE",
    LAWSUIT_RISK = "LAWSUIT_RISK",
    RULES_FAILED = "RULES_FAILED",
    ISSUES_FIXED = "ISSUES_FIXED",
    ACCEPTED_ISSUES = "ACCEPTED_ISSUES"
}
interface ScoreCell {
    metric: ScoreCellMetric;
    value: number | string;
    status: QualityGateRuleStatus;
}
type QueryParamsName = keyof IssueDocumentFilter;
interface QueryParams {
    name: QueryParamsName;
    value: string;
}
interface AlmInstanceSummaryScoreCells extends ScoreCell {
    issueQuery: QueryParams[];
    threshold: number | null;
}

interface Scans {
    managed: number;
    selfHosted: number;
}
interface ProjectDocument {
    id: string;
    organizationSlug: string;
    name: string;
    type: ProjectType;
    integration: Integration;
    testFrameworks: TestFramework[];
    browsers: string[];
    qualityGateStatus: ScanScoreOutcome | null;
    scanned: boolean;
    connected: boolean;
    scope: AnalysisScope | null;
    scoreCells: ScoreCell[];
    externalWorkspaceName: string | null;
    scans: Scans;
    recentScanId: string | null;
    createdAt: DateTime;
    analyzedAt: DateTime | null;
}
interface ListProjectDocumentList extends Pageable<ProjectDocument> {
    organizationSlug: string;
}
interface TagCount {
    title: string;
    count: number;
}
interface TagProjectSet {
    tags: TagCount[];
    total: number;
    afterKey: TagCount;
}
interface TagProjectSearch {
    tags: string;
    afterKey?: TagCount;
}
interface ProjectDocumentFacets {
    severity: Record<ScanRuleSeverity, number>;
    wcag: Record<ScanRuleLevel, number>;
    qualityGateStatus: Record<ScanScoreOutcome, number>;
    lawsuitRisk: Record<LawsuitRiskStatus, number>;
    managedScans: Record<NumberScansFilter, number>;
    selfHostedScans: Record<NumberScansFilter, number>;
    a11yScore: Record<AccessibilityScoreFilter, number>;
    externalWorkspaceName: Record<string, number>;
}
interface ProjectDocumentFilter {
    wcag?: ScanRuleLevel[];
    severity?: ScanRuleSeverity[];
    qualityGateStatus?: ScanScoreOutcome[];
    lawsuitRisk?: LawsuitRiskStatus[];
    managedScans?: NumberScansFilter[];
    selfHostedScans?: NumberScansFilter[];
    a11yScore?: AccessibilityScoreFilter[];
    integration?: Integration[];
    text?: string;
    testFrameworks?: TestFramework[];
    externalWorkspaceName?: string[];
}
declare enum ProjectSortField {
    SEVERITY = "severity",
    ANALYZED_AT = "analyzedAt",
    NAME = "name"
}
interface ProjectSortableQuery {
    order?: SortOrder;
    field?: ProjectSortField;
}
interface ProjectDocumentQuery extends PageableQuery, ProjectSortableQuery, ProjectDocumentFilter {
}

interface ContributorAlmInstance {
    name: string;
    email: string;
}
interface ContributorWithAvatar extends ContributorAlmInstance {
    avatar: string | null;
}
interface ContributorAlmInstanceWithCount extends ContributorAlmInstance {
    count: number;
}
interface ContributorAlmInstanceSet {
    contributor: ContributorAlmInstanceWithCount[];
    total: number;
    afterKey: ContributorAlmInstance | null;
}
interface CommitDataAlmInstance {
    hash: string;
    date: DateTime;
    author: string;
    message: string;
}
interface AlmInstanceDocument {
    id: string;
    projectId: string;
    name: string;
    pullRequestName: string | null;
    type: AlmInstanceType;
    createdAt: DateTime;
    analyzedAt: DateTime | null;
    testFrameworks: TestFramework[];
    browsers: string[];
    qualityGateStatus: ScanScoreOutcome | null;
    scope: AnalysisScope | null;
    retention: RetentionType | null;
    scoreCells: ScoreCell[];
    scans: Scans;
    contributor: ContributorAlmInstance[];
    commit: CommitDataAlmInstance | null;
    recentScanId: string | null;
}
interface AlmUrls {
    commit: string | null;
    pullRequest: string | null;
    branch: string;
    repository: string;
}
interface AlmInstanceDetailsPages {
    scanned: number;
    added: number;
}
interface AlmInstanceDetails {
    targetBranchName: string | null;
    almUrls: AlmUrls | null;
    contributorsWithAvatar: ContributorWithAvatar[];
    qualityGateId: string;
    scoreCells: AlmInstanceSummaryScoreCells[];
    pages: AlmInstanceDetailsPages | null;
}
type AlmInstanceDocumentDetailed = Omit<AlmInstanceDocument, 'contributor' | 'scoreCells'> & AlmInstanceDetails;
declare enum Order {
    ASC = "asc",
    DESC = "desc"
}
interface AlmInstanceDocumentFacets {
    type: Record<AlmInstanceType, number>;
    qualityGateStatus: Record<ScanScoreOutcome, number>;
    lawsuitRisk: Record<LawsuitRiskStatus, number>;
    wcag: Record<ScanRuleLevel, number>;
    severity: Record<ScanRuleSeverity, number>;
    a11yScore: Record<AccessibilityScoreFilter, number>;
    managedScans: Record<NumberScansFilter, number>;
    selfHostedScans: Record<NumberScansFilter, number>;
    contributor: Record<string, number>;
}
interface AlmInstanceDocumentFilter {
    type?: AlmInstanceType[];
    qualityGateStatus?: ScanScoreOutcome[];
    lawsuitRisk?: LawsuitRiskStatus[];
    wcag?: ScanRuleLevel[];
    severity?: ScanRuleSeverity[];
    managedScans?: NumberScansFilter[];
    selfHostedScans?: NumberScansFilter[];
    a11yScore?: AccessibilityScoreFilter[];
    contributor?: string[];
    text?: string;
}
interface AlmInstanceDocumentQuery extends AlmInstanceDocumentFilter, PageableQuery {
    sort?: Order;
}
declare enum AlmInstanceSortField {
    SEVERITY = "severity",
    ANALYZED_AT = "analyzedAt",
    NAME = "title"
}
interface AlmInstanceSortableQuery {
    order?: SortOrder;
    field?: AlmInstanceSortField;
}
interface ContributorSearch {
    contributor: string;
}

interface ConnectionFilterDocument {
    integration?: Integration[];
    text?: string;
}
interface ConnectionDocument {
    id: string;
    organizationId: string;
    integration: Integration;
    name: string;
    isValid: boolean;
    createdAt: DateTime;
    integrationUrl: string;
}
interface ConnectionQuery extends ConnectionFilterDocument, PageableQuery {
}

declare enum LocationType {
    PATH = "path",
    TEMPLATE = "template"
}

interface PageDocument {
    id: string;
    projectId: string;
    scanId: string;
    instanceId: string;
    location: string;
    locationType: LocationType;
    createdAt: DateTime;
}
interface PageDocumentList extends Pageable<PageDocument> {
    branchId: string;
    scanId: string;
}
interface TemplateFacets {
    path: string;
    name: string;
    count: number;
    nodes: Record<string, TemplateFacets>;
}
interface TemplatesFacets {
    nodes: Record<string, TemplateFacets>;
}
type PageDocumentQuery = PageableQuery;

interface ScanProcessConfig {
    assigneeEmail?: string;
    [key: string]: any;
}

interface ServiceHealth {
    status: string;
    service: string;
}
interface ServiceVersions {
    '@userway/cicd-core': string;
    '@userway/cicd-cli': string;
    '@userway/cicd-azure': string;
    '@userway/cicd-bitbucket': string;
    '@userway/cicd-github': string;
    '@userway/cicd-gitlab': string;
}

interface Instance {
    id: string;
    name: string;
    analysisScope: AnalysisScope;
    baseline?: {
        id: string;
        name: string;
    };
}

declare enum IssueType {
    SINGLE = "SINGLE",
    GROUP = "GROUP"
}
declare enum IssueUserAgent {
    MOBILE = "MOBILE",
    DESKTOP = "DESKTOP"
}
declare enum IssueStatus {
    OPEN = "OPEN",
    RESOLVED = "RESOLVED",
    REOPENED = "REOPENED",
    CLOSED = "CLOSED"
}
declare enum IssueResolution {
    FIXED = "FIXED",
    REMOVED = "REMOVED",
    WONTFIX = "WONTFIX",
    FALSE_POSITIVE = "FALSE_POSITIVE",
    UNRESOLVED = "UNRESOLVED"
}
declare enum StatusTransition {
    WONTFIX = "WONTFIX",
    FALSE_POSITIVE = "FALSE_POSITIVE",
    REOPEN = "REOPEN"
}
interface IssueBrief {
    id: string;
    ruleDescriptor: RuleDescriptor$1;
    location: string;
    severity: ScanRuleSeverity;
    level: ScanRuleLevel;
    fixable: boolean;
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface ListIssues extends Pageable<IssueBrief> {
    projectId: string;
    branchId: string;
    scanId: string;
}
interface ScanIssuePayload {
    selector: string;
    xpath: string;
    fingerprint: string;
    testCaseName: string[];
    testCaseFilePath?: string;
    pageHtmlCdnUrl?: string;
    screenshotCdnUrl?: string;
    snippet?: string;
}
interface Issue {
    id: string;
    type: IssueType;
    groupKey: string | null;
    status: IssueStatus;
    resolution: IssueResolution | null;
    assigneeMemberId: string | null;
    authorId: string | null;
    pageId: string;
    ruleKey: string;
    payloadS3Path: string;
    level: ScanRuleLevel;
    severity: ScanRuleSeverity;
    fixable: boolean;
    hasScreenshot: boolean;
    userAgents: IssueUserAgent[];
    createdAt: DateTime;
    updatedAt: DateTime;
}
interface IssueAssignee {
    assigneeMemberId: string | null;
}
interface SetIssueTransition {
    action: StatusTransition;
    comment?: string;
}
interface IssueDetailedElement {
    screenshotUrl: string | null;
    affectedCode: string | null;
    codeLocation: {
        xpath: string;
        selector: string;
        location: string;
    };
}
interface IssueDetailed extends Omit<Issue, 'payloadS3Path'> {
    key: string;
    ruleId: RuleDescriptor$1['id'];
    description: string;
    recommendation: string;
    activity: IssueActivityList;
    tags: Tags;
    elements: IssueDetailedElement[];
    location: string;
    pageScreenshotUrl: string | null;
    pageUrls: string[];
}

declare enum IssueActivityType {
    COMMENT_ADDED = "COMMENT_ADDED",
    CREATED = "CREATED",
    COPIED_FROM = "COPIED_FROM",
    MERGED_FROM = "MERGED_FROM",
    TRANSITION_CHANGED = "TRANSITION_CHANGED",
    ASSIGNEE_CHANGED = "ASSIGNEE_CHANGED",
    TAG_CHANGED = "TAG_CHANGED",
    FIX_MERGED_FROM = "FIX_MERGED_FROM"
}
interface IssueActivityCommentAddedContext {
    text: string;
}
interface IssueActivityCommentAdded {
    type: IssueActivityType.COMMENT_ADDED;
    context: IssueActivityCommentAddedContext;
}
interface IssueActivityCreateContext {
}
interface IssueActivityCreated {
    type: IssueActivityType.CREATED;
    context: IssueActivityCreateContext;
}
interface IssueActivityCopiedFromContext {
    fromInstanceName: string;
    toInstanceName: string;
}
interface IssueActivityCopiedFrom {
    type: IssueActivityType.COPIED_FROM;
    context: IssueActivityCopiedFromContext;
}
interface IssueActivityMergedFromContext {
    fromInstanceName: string;
    toInstanceName: string;
}
interface IssueActivityMergedFrom {
    type: IssueActivityType.MERGED_FROM;
    context: IssueActivityMergedFromContext;
}
interface IssueTransition {
    status: IssueStatus;
    resolution: IssueResolution;
}
interface IssueActivityTransitionChangedContext {
    previous: IssueTransition;
    new: IssueTransition;
    text?: string;
}
interface IssueActivityTransitionChanged {
    type: IssueActivityType.TRANSITION_CHANGED;
    context: IssueActivityTransitionChangedContext;
}
interface IssueActivityAssigneeChangedContext {
    previous: string | null;
    new: string | null;
}
interface IssueActivityAssigneeChanged {
    type: IssueActivityType.ASSIGNEE_CHANGED;
    context: IssueActivityAssigneeChangedContext;
}
interface IssueActivityTagChangedContext {
    previous: string[];
    new: string[];
}
interface IssueActivityTagChanged {
    type: IssueActivityType.TAG_CHANGED;
    context: IssueActivityTagChangedContext;
}
interface IssueActivityFixMergedFromContext {
    fromInstanceName: string;
    toInstanceName: string;
}
interface IssueActivityFixMergedFrom {
    type: IssueActivityType.FIX_MERGED_FROM;
    context: IssueActivityFixMergedFromContext;
}
type IssueActivityBase = IssueActivityTagChanged | IssueActivityAssigneeChanged | IssueActivityTransitionChanged | IssueActivityMergedFrom | IssueActivityCopiedFrom | IssueActivityCreated | IssueActivityCommentAdded | IssueActivityFixMergedFrom;
interface IssueActivityMeta {
    id: string;
    issueId: string;
    authorMemberId: string | null;
    createdAt: DateTime;
}
interface IssueActivity extends IssueActivityMeta {
    type: IssueActivityBase['type'];
    context: IssueActivityBase['context'];
}
interface IssueActivityDetailed extends IssueActivity {
    ssoUserId: string | null;
}
/** A better typed version of {@link IssueActivity} */
type IssueActivityItem = IssueActivityBase & IssueActivityMeta;
type IssueActivityList = Pageable<IssueActivity>;
interface IssueCommentAdd {
    text: string;
}

interface NewOrganization {
    name: string;
    slug?: string;
}
interface OrganizationUpdate {
    newName: string;
    newSlug: string;
}
interface Organization {
    id: string;
    name: string;
    slug: string;
    createdAt: DateTime;
    updatedAt: DateTime;
}
declare enum OrganizationType {
    PERSONAL = "PERSONAL",
    DETACHED = "DETACHED"
}
interface OrganizationMembership {
    name: string;
    slug: string;
    type: OrganizationType;
    accountId: string;
    imageUrl: string;
    roles: GrantedMemberRole[];
    membersNum: number;
    projectsNum: number;
    ssoMemberId: string | null;
    updatedAt: DateTime;
}
interface OrganizationMembershipList extends Pageable<OrganizationMembership> {
    userId: string;
}
interface OrganizationList extends Pageable<Organization> {
    userId: string;
}
interface SetAvatar {
    filename: string;
    content: string;
}
interface Avatar {
    avatarUrl: string | null;
    updatedAt: DateTime;
}
interface RemoveUserPicture {
    removeUserPictureUrl: string;
}
interface GetOrganizations extends PageableQuery {
    type: Ca11yMemberInvitationStatus;
}

interface SsoAuthTokenDto {
    accessToken: string;
    refreshToken: string;
    userRoles: string[];
}
declare enum MfaMethod {
    VIRTUAL_MFA = "VIRTUAL_MFA",
    EMAIL_MFA = "EMAIL_MFA"
}
interface LoginBody {
    username: string;
    password: string;
    verificationCode: string | null;
    mfaMethod: MfaMethod | null;
}
interface RenameUserBody {
    firstName: string;
    lastName: string | null;
}
interface TokenPair {
    accessToken: string;
    refreshToken: string;
}
interface AuthData extends TokenPair {
    organizationSlug: string;
}
interface SignUpData {
    auth: TokenPair;
    email: string;
    ssoUserId: string;
    slug: string;
    accountCode: string;
}
interface SignUpBody {
    email: string;
    password: string;
    firstName: string;
    lastName: string | null;
    phone: string | null;
}
interface ChangeEmailBody {
    newEmail: string;
    password: string;
}
interface ChangePasswordBody {
    newPassword: string;
    oldPassword: string;
}
interface SsoAuthUser {
    userId: string;
    auth: SsoAuthTokenDto;
}
interface SsoUserInfo {
    userId: string;
    userEmail: string;
    accountCode: string;
    userFirstName: string;
    userLastName: string;
    accountName: string;
    slug: string;
    userPhone: string;
    userType: SsoUserType;
    userRoles: SsoUserRole[];
    userCreatedOn: Date;
    updatedAt: DateTime;
    profilePictureImageUri: string;
    profilePictureImageUrl: string;
    credibilityStatus: SsoEmailCredibilityStatus;
    accountDomain: string | null;
    allowedLoginMechanisms: SsoUserLoginMechanism[];
    oauthRegistrationId: string | null;
    protocolType: SsoProtocolType | null;
    registrationType: UserRegistrationType;
    registrationOrigin: RegistrationOrigin;
    defaultCa11yOrganizationId: string;
}
declare enum SsoUserType {
    SITE_USER = "SITE_USER",
    SITE_ADMIN = "SITE_ADMIN",
    SITE_MASTER = "SITE_MASTER"
}
declare enum SsoUserRole {
    ROLE_MASTER = "ROLE_MASTER",
    ROLE_ADMIN = "ROLE_ADMIN",
    ROLE_USER = "ROLE_USER"
}
declare enum SsoEmailCredibilityStatus {
    EMAIL_CREDIBLE = "EMAIL_CREDIBLE",
    EMAIL_UNCREDIBLE = "EMAIL_UNCREDIBLE"
}
declare enum SsoUserLoginMechanism {
    CREDENTIALS_LOGIN = "CREDENTIALS_LOGIN",
    SOCIAL_LOGIN = "SOCIAL_LOGIN",
    SSO_LOGIN = "SSO_LOGIN"
}
declare enum SsoProtocolType {
    OAUTH = "OAUTH",
    SAML = "SAML"
}
declare enum UserRegistrationType {
    USER_REGISTRATION = "USER_REGISTRATION",
    MEMBER_INVITATION = "MEMBER_INVITATION"
}
declare enum RegistrationOrigin {
    UNKNOWN = "UNKNOWN",
    ADMIN = "ADMIN",
    USER = "USER",
    TEST = "TEST",
    WIX = "WIX",
    WORDPRESS = "WORDPRESS",
    SHOPIFY = "SHOPIFY",
    SITE_GENERAL = "SITE_GENERAL",
    SITE = "SITE",
    SSO = "SSO",
    SITE_COMPANY_FORM = "SITE_COMPANY_FORM",
    SITE_CONTACT_US_FORM = "SITE_CONTACT_US_FORM",
    SITE_RESELLER_FORM = "SITE_RESELLER_FORM",
    SITE_WEBINAR_FORM = "SITE_WEBINAR_FORM",
    SITE_SUPPORT_FORM = "SITE_SUPPORT_FORM",
    SITE_CODE = "SITE_CODE",
    MANAGE_SIGN_UP = "MANAGE_SIGN_UP",
    INSPECTOR_SIGN_UP = "INSPECTOR_SIGN_UP",
    API_REQUEST = "API_REQUEST",
    AUDIT = "AUDIT",
    BIG_COMMERCE = "BIG_COMMERCE",
    DUDA = "DUDA",
    MAGENTO = "MAGENTO",
    JOOMLA = "JOOMLA",
    SEMRUSH = "SEMRUSH",
    SEMRUSH_WIDGET = "SEMRUSH_WIDGET",
    SQUAREUP = "SQUAREUP",
    SHORTPOINT = "SHORTPOINT",
    DRUPAL = "DRUPAL",
    ENVATO = "ENVATO",
    CAFE24 = "CAFE24",
    WHITEPAPER_REQUEST = "WHITEPAPER_REQUEST",
    FACEBOOK_LEAD_AD = "FACEBOOK_LEAD_AD",
    HANDBOOK = "HANDBOOK",
    VPAT = "VPAT",
    PDF = "PDF",
    WEBINAR_FEEDBACK = "WEBINAR_FEEDBACK",
    AFFILIATE_SIGNUP_FORM = "AFFILIATE_SIGNUP_FORM",
    AFFILIATE_MEETING = "AFFILIATE_MEETING",
    WEBSUMMIT_SIGNUP = "WEBSUMMIT_SIGNUP",
    COLLISION_SIGNUP = "COLLISION_SIGNUP",
    STATEMENT_GENERATOR_FORM = "STATEMENT_GENERATOR_FORM",
    DEMO_REQUEST_FORM = "DEMO_REQUEST_FORM",
    DEMO_REQUEST_SHORT_FORM = "DEMO_REQUEST_SHORT_FORM",
    CONTACT_AN_EXPERT = "CONTACT_AN_EXPERT",
    MANAGED_ACCESSIBILITY = "MANAGED_ACCESSIBILITY",
    MS_OFFICE_FORM = "MS_OFFICE_FORM",
    ENTERPRISE_REQUEST = "ENTERPRISE_REQUEST",
    SCANNER_SIGNUP = "SCANNER_SIGNUP",
    TUNINGS_REQUEST = "TUNINGS_REQUEST",
    CALENDLY = "CALENDLY",
    LINKEDIN_OUTREACH = "LINKEDIN_OUTREACH",
    SCANNER_SLG = "SCANNER_SLG",
    LEGAL_SUPPORT = "LEGAL_SUPPORT",
    ONBOARDING = "ONBOARDING",
    DASHBOARD = "DASHBOARD",
    LEVEL_ACCESS = "LEVEL_ACCESS",
    HUSKY = "HUSKY"
}
declare enum GrantedMemberRole {
    ACCOUNT_OWNER = "ACCOUNT_OWNER",
    ORGANIZATION_ADMIN = "ORGANIZATION_ADMIN",
    SITES_VIEWER = "SITES_VIEWER",
    SITES_MANAGER = "SITES_MANAGER",
    SCANS_MANAGER = "SCANS_MANAGER",
    IMAGE_ALTS_MANAGER = "IMAGE_ALTS_MANAGER",
    PDFS_MANAGER = "PDFS_MANAGER",
    MEMBERS_MANAGER = "MEMBERS_MANAGER",
    BILLING_MANAGER = "BILLING_MANAGER",
    INTEGRATION_MANAGER = "INTEGRATION_MANAGER",
    WIDGET_APPEARANCE_MANAGER = "WIDGET_APPEARANCE_MANAGER",
    WIDGET_EXPOSED_API_CALLER = "WIDGET_EXPOSED_API_CALLER",
    TEAM_AND_UNIT_MANAGER = "TEAM_AND_UNIT_MANAGER",
    SITE_MANAGER = "SITE_MANAGER",
    TEAM_MEMBER = "TEAM_MEMBER",
    LEVEL_ACCESS_MEMBER = "LEVEL_ACCESS_MEMBER",
    LEVEL_ACCESS_MANAGER = "LEVEL_ACCESS_MANAGER",
    CA11Y_PROJECTS_VIEWER = "CA11Y_PROJECTS_VIEWER",
    CA11Y_PROJECTS_MANAGER = "CA11Y_PROJECTS_MANAGER",
    CA11Y_MEMBERS_MANAGER = "CA11Y_MEMBERS_MANAGER",
    CA11Y_BILLING_MANAGER = "CA11Y_BILLING_MANAGER",
    CA11Y_INTEGRATION_MANAGER = "CA11Y_INTEGRATION_MANAGER",
    LABS_DEVELOPER = "LABS_DEVELOPER",
    LABS_OWNER = "LABS_OWNER"
}
declare enum Ca11yMemberRole {
    CA11Y_PROJECTS_VIEWER = "CA11Y_PROJECTS_VIEWER",
    CA11Y_PROJECTS_MANAGER = "CA11Y_PROJECTS_MANAGER",
    CA11Y_MEMBERS_MANAGER = "CA11Y_MEMBERS_MANAGER",
    CA11Y_BILLING_MANAGER = "CA11Y_BILLING_MANAGER",
    CA11Y_INTEGRATION_MANAGER = "CA11Y_INTEGRATION_MANAGER",
    ORGANIZATION_ADMIN = "ORGANIZATION_ADMIN"
}
interface JwtRestriction {
    roleName: GrantedMemberRole;
    roleScope: string[];
}
interface TargetAccountRecord {
    targetSsoUserId: string;
    targetAccountCode: string;
    targetAccountSlug: string;
    requiredMfa: boolean;
    restrictions: JwtRestriction[];
}
interface TokenExtendedDetails {
    targetAccounts: TargetAccountRecord[];
}
interface AccountMfaInfoResponse {
    enabledVirtualMfa: {
        virtualMfaDeviceName: string;
    } | null;
    enabledEmailMfa: {
        emailMfaEmailAddress: string;
    } | null;
}
interface InitializeVirtualMfa {
    qrCodeBase64: string;
}
interface ConfirmVirtualMfa {
    verificationCode: string;
    deviceName: string;
}
interface ConfirmVirtualMfaResponse {
    recoveryCodes: string[];
}
interface ConfirmEmailMfa {
    verificationCode: string;
}
interface SendEmailMfa {
    email: string;
}

interface InviteMembers {
    inviteMemberEmails: string[];
}
interface MemberId {
    ssoMemberId: string;
}
interface RemoveMember {
    memberId: string;
}
interface InviteSingleMember {
    firstName: string;
    lastName: string | null;
    email: string;
}
interface InviteMembersResponse {
    inviteMemberResults: Record<string, MessageResponse>;
}
interface InviteMembersResponse {
    inviteMemberResults: Record<string, MessageResponse>;
}
interface UpdateMemberPermissions {
    accountMemberRoles: GrantedMemberRole[];
}
declare enum Ca11yGrantedMemberStatus {
    OWNER = "OWNER",
    ACTIVE_MEMBER = "ACTIVE_MEMBER",
    NON_ACTIVE_MEMBER = "NON_ACTIVE_MEMBER"
}
declare enum Ca11yMemberInvitationStatus {
    INVITATION_SENT = "INVITATION_SENT",
    INVITATION_ACCEPTED = "INVITATION_ACCEPTED",
    INVITATION_REJECTED = "INVITATION_REJECTED",
    INVITATION_WITHDRAWN = "INVITATION_WITHDRAWN"
}
declare enum MemberStatus {
    ACTIVE = "ACTIVE",
    SUSPENDED = "SUSPENDED",
    REMOVED = "REMOVED"
}
interface Member {
    id: string;
    ssoUserId: string;
    email: string;
    firstName: string;
    lastName: string | null;
    organizationId: string;
    memberActiveStatus: MemberStatus;
    ssoMemberId: string;
    memberRoles: GrantedMemberRole[] | null;
    memberStatus: Ca11yGrantedMemberStatus | null;
    invitationStatus: Ca11yMemberInvitationStatus | null;
    lockedByEmailDomainMismatch: boolean | null;
    createdAt: DateTime;
    avatarPath: string | null;
}
interface MembersList {
    members: Member[];
}
interface GenerateInviteUrlBody {
    roles: Ca11yMemberRole[];
}
declare enum InvitationStatus {
    ACTIVE = "ACTIVE",
    DEACTIVATED = "DEACTIVATED"
}
interface InvitationUrl {
    url: string;
}
interface InvitationParams {
    token: string;
    organizationSlug: string;
}
interface Invitation {
    id: string;
    organizationId: string;
    status: InvitationStatus;
    token: string;
    roles: Ca11yMemberRole[];
    createdAt: DateTime;
    expiredAt: DateTime;
}

interface JiraInstalled {
    baseUrl: string;
    displayUrl: string;
    clientKey: string;
    sharedSecret: string;
}
interface JiraInstallation {
    id: string;
    baseUrl: string;
    displayUrl: string;
}

type AlmInstanceReindexDocument = Pick<AlmInstanceDocument, 'id'>;

type ConnectionReindexDocument = Pick<ConnectionDocument, 'id' | 'integration'>;

type IssueReindexDocument = Pick<IssueDocument, 'id'>;

type PageReindexDocument = Pick<PageDocument, 'id'>;

type ProjectReindexDocument = Pick<ProjectDocument, 'id'>;

interface ScanDocument {
    id: string;
    instanceId: string;
    projectName: string;
    organizationSlug: string;
    integration: Integration;
    status: ScanStatus;
    errorType: ContinuousAccessibilityApiErrorType;
    createdAt: string;
}

type ScanReindexDocument = Pick<ScanDocument, 'id'>;

declare enum ElasticDocumentType {
    ISSUE = "ISSUE",
    PROJECT = "PROJECT",
    ALM_INSTANCE = "ALM_INSTANCE",
    PAGE = "PAGE",
    CONNECTION = "CONNECTION",
    SCAN = "SCAN"
}
interface IssueReindexDocumentBatch {
    type: ElasticDocumentType.ISSUE;
    data: IssueReindexDocument[];
}
interface ProjectReindexDocumentBatch {
    type: ElasticDocumentType.PROJECT;
    data: ProjectReindexDocument[];
}
interface PageReindexDocumentBatch {
    type: ElasticDocumentType.PAGE;
    data: PageReindexDocument[];
}
interface AlmInstanceReindexDocumentBatch {
    type: ElasticDocumentType.ALM_INSTANCE;
    data: AlmInstanceReindexDocument[];
}
interface ConnectionReindexDocumentBatch {
    type: ElasticDocumentType.CONNECTION;
    data: ConnectionReindexDocument[];
}
interface ScanReindexDocumentBatch {
    type: ElasticDocumentType.SCAN;
    data: ScanReindexDocument[];
}
type DocumentReindexBatch = IssueReindexDocumentBatch | ProjectReindexDocumentBatch | PageReindexDocumentBatch | AlmInstanceReindexDocumentBatch | ConnectionReindexDocumentBatch | ScanReindexDocumentBatch;

declare enum CoreLambdaResponseStatus {
    OK = "OK",
    NOK = "NOK"
}
interface CoreLambdaResponse {
    scanId: string;
    url: string;
    status: CoreLambdaResponseStatus;
    required: boolean;
    errorType: string | null;
    errorMessage: string | null;
}
interface CoreLambdaResponses {
    items: CoreLambdaResponse[];
}

interface ScanStats {
    scanId: string;
    scannedPagesNum: number;
    totalTests: number;
    issuesNum: number;
    closedIssuesNum: number;
    issuesMinorNum: number;
    issuesModerateNum: number;
    issuesSeriousNum: number;
    issuesCriticalNum: number;
    issuesANum: number;
    issuesAANum: number;
    issuesAAANum: number;
    issuesBestPracticeNum: number;
    issuesExperimentalNum: number;
    rulesCheckedNum: number;
    rulesFailedNum: number;
    rulesSucceedNum: number;
    a11yScore: number;
    createdAt: DateTime;
    updatedAt: DateTime;
}

interface ScanTemplateViolation {
    ruleKey: string;
    ruleDescriptor: RuleDescriptor$1;
    count: number;
}
interface ScanTemplateViolationDto {
    ruleKey: string;
    ruleDescriptor: RuleDescriptor;
    count: number;
}
interface ScanTemplateViolationList {
    violations: ScanTemplateViolationDto[];
    projectId: string;
    scanId: string;
}

declare class Tags {
    tags: string[];
}

declare enum Ca11yCustomHeader {
    CA11LY_THROW_REQUESTED_ERROR_MESSAGE = "CA11LY_THROW_REQUESTED_ERROR_MESSAGE",
    CA11LY_THROW_REQUESTED_REQUEST_PATH_MATCHER = "CA11LY_THROW_REQUESTED_REQUEST_PATH_MATCHER"
}
type Ca11yCustomHeaders = Partial<Record<Ca11yCustomHeader, string>>;

export { A11yTransactionType, AccessibilityScoreFilter, type AccountMfaInfoResponse, type Action, Alm, type AlmInstance, type AlmInstanceDetails, type AlmInstanceDetailsPages, type AlmInstanceDocument, type AlmInstanceDocumentDetailed, type AlmInstanceDocumentFacets, type AlmInstanceDocumentFilter, type AlmInstanceDocumentQuery, type AlmInstanceGroupCount, type AlmInstanceList, type AlmInstanceReindexDocument, type AlmInstanceReindexDocumentBatch, AlmInstanceSortField, type AlmInstanceSortableQuery, type AlmInstanceSummaryScoreCells, AlmInstanceType, type AlmUrls, AnalysisScope, type Artifact, ArtifactSource, ArtifactType, type Assignee, type AuthData, type Avatar, type AzureOrganization, type AzureReport, type AzureRepositories, type AzureRepository, type AzureRepositoryEntity, type BasicAuth, type BillingAddress, type BillingBanner, type BillingBannerResponse, BillingBannerType, type BillingEmailUser, type BillingEmailUsers, type BillingEmails, BillingMethod, type BillingOrderItem, BillingProvider, type BillingUserService, type BillingUserwaySubscription, type BitbucketCreatedRepositories, type BitbucketCreatedRepository, type BitbucketInstallation, type BitbucketInstalled, type BitbucketPipeLastVersion, type BitbucketRepositories, type BitbucketRepository, type BitbucketRepositoryEntity, type BitbucketUninstalled, type BitbucketWidgetPayload, type BitbucketWidgetProjectPayload, type BitbucketWorkspace, type BitbucketWorkspaceWithInstallation, type Ca11yAddon, Ca11yCustomHeader, type Ca11yCustomHeaders, Ca11yGrantedMemberStatus, Ca11yMemberInvitationStatus, Ca11yMemberRole, Ca11yTierType, type CalculateCartBody, type CalculateCartPricing, type CalculateCartSubscriptionUpgradeBody, type CancelTrial, type CardDetails, type CartInvoiceTotals, type ChangeEmailBody, type ChangePasswordBody, type CloseBanner, type CommitDataAlmInstance, type CommitScan, type CommitScanConfig, type CommitScanConfigPage, type CommitScanStatus, type ConfirmEmailMfa, type ConfirmVirtualMfa, type ConfirmVirtualMfaResponse, type Connection, type ConnectionDocument, type ConnectionFilterDocument, type ConnectionQuery, type ConnectionReindexDocument, type ConnectionReindexDocumentBatch, ContinuousAccessibilityApiErrorType, type ContributorAlmInstance, type ContributorAlmInstanceSet, type ContributorAlmInstanceWithCount, type ContributorSearch, type ContributorWithAvatar, type CoreLambdaResponse, CoreLambdaResponseStatus, type CoreLambdaResponses, type CountByOrganizationIds, type CreateAzureOrganization, type CreateAzureRepositories, type CreateAzureRepository, type CreateBitbucketRepositories, type CreateBitbucketRepository, type CreateBitbucketWorkspace, type CreateGitHubRepositories, type CreateGitHubRepository, type CreateGitLabConnection, type CreateGitLabRepositories, type CreateGitLabRepository, type CreateProject, type CreateProjectSettings, type CreateRepositories, type CreateRepository, type CreateRepositoryEntity, type CreateRepositorySettings, type CreateSubscription, type CreateTopUp, type CreatedAzureRepositories, type CreatedAzureRepository, type CreatedGitHubRepository, type CreatedGitLabRepositories, type CreatedGitLabRepository, type CreatedGithubRepositories, type CreatedManualRepositories, type DateTime, type Delay, type Device, type DocumentReindexBatch, type DowngradeSubscriptionBody, ElasticDocumentType, type FinalizeArtifactConfiguration, type FormAuth, type GenerateInviteUrlBody, type GetGitLabProjectsQuery, type GetHelperProductsBody, type GetOrganizations, type GetPdfInvoice, type GetSubscription, type GitHubInstallation, type GitHubOrganization, type GitHubRepositories, type GitHubRepository, type GitHubRepositoryEntity, type GitLabConnectionResponse, type GitLabProject, type GitLabProjects, type GitLabProjectsResponse, type GitLabRepositoryEntity, type GitLabRepositoryRepositoryDto, GrantedMemberRole, type InitializeVirtualMfa, type Instance, Integration, type Invitation, type InvitationParams, InvitationStatus, type InvitationUrl, type InviteMembers, type InviteMembersResponse, type InviteSingleMember, type IsDowngradeAvailable, type IsDowngradeAvailableResponse, type Issue, type IssueActivity, type IssueActivityAssigneeChanged, type IssueActivityAssigneeChangedContext, type IssueActivityBase, type IssueActivityCommentAdded, type IssueActivityCommentAddedContext, type IssueActivityCopiedFrom, type IssueActivityCopiedFromContext, type IssueActivityCreateContext, type IssueActivityCreated, type IssueActivityDetailed, type IssueActivityFixMergedFrom, type IssueActivityFixMergedFromContext, type IssueActivityItem, type IssueActivityList, type IssueActivityMergedFrom, type IssueActivityMergedFromContext, type IssueActivityMeta, type IssueActivityTagChanged, type IssueActivityTagChangedContext, type IssueActivityTransitionChanged, type IssueActivityTransitionChangedContext, IssueActivityType, type IssueAssignee, type IssueBrief, type IssueCommentAdd, type IssueDetailed, type IssueDetailedElement, type IssueDocument, type IssueDocumentAssignee, type IssueDocumentFacets, type IssueDocumentFilter, type IssueDocumentList, type IssueDocumentQuery, type IssueFacetsAssignee, type IssueReindexDocument, type IssueReindexDocumentBatch, IssueResolution, IssueSortField, type IssueSortableQuery, IssueStatus, type IssueTransition, IssueType, IssueUserAgent, type JiraInstallation, type JiraInstalled, type JwtRestriction, LawsuitRiskStatus, type ListIssues, type ListProjectDocumentList, type ListQualityGate, LocationType, type LoginBody, type Member, type MemberId, MemberStatus, type MembersList, type MessageResponse, MfaMethod, type NewManualRepository, type NewOrganization, type NewQualityGate, type NewQualityGateCondition, type NotFoundErrorType, NumberScansFilter, Order, type Organization, type OrganizationList, type OrganizationMembership, type OrganizationMembershipList, OrganizationType, type OrganizationUpdate, type PackageLastVersion, type Page, type PageDocument, type PageDocumentList, type PageDocumentQuery, type PageReindexDocument, type PageReindexDocumentBatch, type Pageable, type PageableQuery, type PaymentHistory, type PaymentHistoryList, type PaymentMethodDetails, type PaymentMethodsList, type PaymentType, type Product, type ProductStaticPrices, type ProductStaticPricesTier, type Project, type ProjectBriefInfo, type ProjectDecryptedToken, type ProjectDocument, type ProjectDocumentFacets, type ProjectDocumentFilter, type ProjectDocumentQuery, type ProjectList, type ProjectNameCompatible, type ProjectNameExists, type ProjectQualityGateData, type ProjectReindexDocument, type ProjectReindexDocumentBatch, type ProjectSettings, type ProjectSettingsAlm, type ProjectSettingsAlmInfo, type ProjectSettingsBase, type ProjectSettingsSite, type ProjectSetupInstructions, ProjectSortField, type ProjectSortableQuery, ProjectType, type QualityGate, QualityGateAction, type QualityGateCondition, type QualityGateConditionBatch, type QualityGateConditionBrief, type QualityGateConditionBriefBatch, type QualityGateConditions, QualityGateMetric, type QualityGateMetricBatch, type QualityGateMetricConditions, QualityGateMetricInitial, QualityGateMetricSummary, QualityGateOperator, QualityGateRuleStatus, QualityGateScope, type QualityGateTable, type QualityGateTableCondition, type QualityGateTableRow, type QualityGateWithUsedProjectsData, type QueryParams, type QueryParamsName, type ReconnectAzureOrganization, type ReconnectGitLabConnection, RegistrationOrigin, type RemoveMember, type RemoveUserPicture, type RenameMainBranch, type RenameQualityGate, type RenameUserBody, type Repository, RetentionType, type RuleDescriptor, type RuleDescriptorReference, type Scan, type ScanArtifact, type ScanArtifactUploadData, type ScanArtifactUploadFormData, type ScanArtifactUploadMeta, type ScanArtifactUploadResult, type ScanArtifactUploadResultData, ScanArtifactUploadStatus, type ScanConsumptionResponse, type ScanDocumentFilter, type ScanDocumentQuery, type ScanIssuePayload, type ScanList, type ScanProcessConfig, type ScanReindexDocument, type ScanReindexDocumentBatch, type ScanRelations, ScanRuleLevel, ScanRuleSeverity, type ScanScore, ScanScoreOutcome, ScanSortField, type ScanSortableQuery, type ScanStats, ScanStatus, type ScanTemplateViolation, type ScanTemplateViolationDto, type ScanTemplateViolationList, type Scans, type ScansConsumption, type ScansConsumptionQuery, type ScoreCell, ScoreCellMetric, type ScriptAuth, type SendEmailMfa, type ServiceHealth, type ServiceVersions, type SetAvatar, type SetDefaultAssignee, type SetIssueTransition, type SignUpBody, type SignUpData, SortOrder, type SsoAuthTokenDto, type SsoAuthUser, SsoEmailCredibilityStatus, SsoProtocolType, type SsoUserInfo, SsoUserLoginMechanism, SsoUserRole, SsoUserType, type StaticPrices, StatusTransition, type StripeCustomerId, type Subscription, SubscriptionBillingCycleType, type SubscriptionInfo, SubscriptionStatus, type SubscriptionTypeInfo, type TagCount, type TagProjectSearch, type TagProjectSet, Tags, type TargetAccountRecord, type TemplateFacets, type TemplatesFacets, TestFramework, type ToggleAutoRenew, type TokenExtendedDetails, type TokenPair, type TopUp, type UpdateMemberPermissions, type UpdateProjectName, type UpdateProjectSettingsDetectTemplateIssues, type UpdateProjectSettingsGateId, type UpdateProjectSettingsGateStatus, type UpdateProjectSettingsIgnoreFixable, type UpdateProjectSettingsPageTemplates, type UpdateProjectSettingsUrlParams, type UpdateQualityGateCondition, type UpgradeSubscriptionBody, UserRegistrationType, UserServiceStatus, WebInfoOrigin };
